// services/ApiService.ts - Backend API integration service
import AsyncStorage from '@react-native-async-storage/async-storage';

interface LoginResponse {
  success: boolean;
  message: string;
  data?: {
    user: {
      userId: string;
      username: string;
      email: string;
      suiAddress: string;
      profileObjectId?: string;
      rank: string;
      createdAt: string;
      lastLoginAt?: string;
    };
    wallet: {
      address: string;
      balance: string;
      suiBalance: string;
      verified: boolean;
    };
    profile?: {
      rank: string;
      totalTreasuresFound: number;
      totalScore: number;
      currentStreak: number;
    };
    token: string;
    tokenExpiresIn: string;
    notes?: {
      walletVerified: boolean;
      blockchainProfileCreated: boolean;
      needsFaucet: boolean;
    };
  };
  error?: string;
}

interface RegisterResponse {
  success: boolean;
  message: string;
  data?: {
    user: {
      userId: string;
      username: string;
      email: string;
      suiAddress: string;
      profileObjectId?: string;
      rank: string;
      createdAt: string;
    };
    wallet: {
      address: string;
      balance: string;
      suiBalance: string;
      verified: boolean;
    };
    token: string;
    tokenExpiresIn: string;
    notes?: {
      walletVerified: boolean;
      blockchainProfileCreated: boolean;
      needsFaucet: boolean;
    };
  };
  error?: string;
}

interface NearbyTreasuresResponse {
  success: boolean;
  message: string;
  data?: {
    treasures: Array<{
      treasureId: string;
      name: string;
      description: string;
      latitude: number;
      longitude: number;
      rarity: number;
      rarityName: string;
      rewardPoints: number;
      distance: number;
      canHunt: boolean;
      imageUrl: string;
      requiredRank: number;
      requiredRankName: string;
    }>;
    total: number;
    userLocation: {
      latitude: number;
      longitude: number;
    };
    searchRadius: number;
    userProfile: {
      rank: string;
      rankNumber: number;
      totalTreasuresFound: number;
    };
  };
}

interface TreasureDiscoveryResponse {
  success: boolean;
  message: string;
  data?: {
    discovery: {
      discoveryId: string;
      discoveredAt: string;
      distance: number;
      method: string;
    };
    nft?: {
      objectId: string;
      transactionDigest: string;
      blockHeight?: number;
      onChain: boolean;
      explorerUrl?: string;
    };
    treasure: {
      treasureId: string;
      name: string;
      description: string;
      rarity: number;
      rarityName: string;
      rewardPoints: number;
      imageUrl: string;
      source?: string;
      wasAutoGenerated?: boolean;
    };
    profile: {
      oldRank: string;
      newRank: string;
      rankUpgraded: boolean;
      oldScore: number;
      newScore: number;
      pointsEarned: number;
      totalTreasures: number;
      currentStreak: number;
      longestStreak: number;
    };
  };
}

interface ProfileStatsResponse {
  success: boolean;
  data?: {
    user: {
      userId: string;
      username: string;
      email: string;
      suiAddress: string;
      profileObjectId?: string;
      avatarUrl?: string;
      createdAt: string;
      lastLoginAt?: string;
    };
    profile: {
      rank: string;
      rankInfo: any;
      totalTreasuresFound: number;
      totalScore: number;
      currentStreak: number;
      longestStreak: number;
      lastHuntTimestamp?: string;
      streakInfo: any;
    };
    wallet: {
      balance: string;
      balanceSui: string;
      totalEarned: number;
      totalEarnedSui: string;
    };
    achievements: {
      total: number;
      recent: any[];
      totalPoints: number;
    };
    leaderboard: {
      position: number | null;
      percentile: number | null;
    };
    recentActivity: {
      discoveries: any[];
    };
    statistics: any;
  };
}

interface WalletBalanceResponse {
  success: boolean;
  data?: {
    wallet: {
      address: string;
      balance: string;
      suiBalance: string;
      network: string;
    };
    stats: {
      totalTransactions: number;
      totalEarned: number;
      totalEarnedSui: string;
    };
    user: {
      username: string;
      profileObjectId?: string;
      hasBlockchainProfile: boolean;
    };
  };
}

interface NFTCollectionResponse {
  success: boolean;
  data?: {
    nfts: Array<{
      id: string;
      nftObjectId: string;
      treasureId: string;
      name: string;
      description: string;
      rarity: number;
      rarityName: string;
      imageUrl: string;
      discoveredAt: string;
      onChain: boolean;
      explorerUrl?: string;
    }>;
    stats: {
      total: number;
      onChain: number;
      byRarity: Record<string, number>;
    };
    wallet: {
      address: string;
      network: string;
    };
  };
}

interface FaucetResponse {
  success: boolean;
  message: string;
  data?: {
    transactionDigests: string[];
    newBalance: string;
    newBalanceSui: string;
    transactionId: string;
  };
}

export class ApiService {
  private baseUrl: string;
  private authToken: string | null = null;

  constructor(baseUrl: string = 'https://treasuryhunterbackend.onrender.com/api/v1') {
    this.baseUrl = baseUrl;
    this.loadAuthToken();
  }

  /**
   * Load auth token from AsyncStorage
   */
  private async loadAuthToken(): Promise<void> {
    try {
      this.authToken = await AsyncStorage.getItem('auth_token');
    } catch (error) {
      console.error('Failed to load auth token:', error);
    }
  }

  /**
   * Set auth token and save to storage
   */
  async setAuthToken(token: string): Promise<void> {
    this.authToken = token;
    try {
      await AsyncStorage.setItem('auth_token', token);
    } catch (error) {
      console.error('Failed to save auth token:', error);
    }
  }

  /**
   * Clear auth token
   */
  async clearAuthToken(): Promise<void> {
    this.authToken = null;
    try {
      await AsyncStorage.removeItem('auth_token');
    } catch (error) {
      console.error('Failed to clear auth token:', error);
    }
  }

  /**
   * Get auth headers
   */
  private getAuthHeaders(): Record<string, string> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };

    if (this.authToken) {
      headers['Authorization'] = `Bearer ${this.authToken}`;
    }

    return headers;
  }

  /**
   * Make API request
   */
  private async request<T>(
    endpoint: string,
    options: {
      method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
      body?: any;
      requireAuth?: boolean;
      headers?: Record<string, string>;
    } = {}
  ): Promise<T> {
    const {
      method = 'GET',
      body,
      requireAuth = true,
      headers = {},
    } = options;

    // Ensure auth token is loaded
    if (requireAuth && !this.authToken) {
      await this.loadAuthToken();
    }

    const requestHeaders = requireAuth ? this.getAuthHeaders() : { 'Content-Type': 'application/json' };
    const config: RequestInit = {
      method,
      headers: {
        ...requestHeaders,
        ...headers,
      },
    };

    if (body) {
      config.body = JSON.stringify(body);
    }

    const url = `${this.baseUrl}${endpoint}`;
    console.log(`üì° API ${method} ${url}`);

    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`‚ùå API Error: ${response.status} - ${errorText}`);
        
        // Handle authentication errors
        if (response.status === 401) {
          await this.clearAuthToken();
          throw new Error('Authentication failed. Please log in again.');
        }
        
        throw new Error(`API Error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      console.log(`‚úÖ API ${method} ${endpoint} - Success`);
      
      return data;
    } catch (error) {
      console.error(`‚ùå API ${method} ${endpoint} failed:`, error);
      throw error;
    }
  }

  // ==================== AUTH ENDPOINTS ====================

  /**
   * Login with email and optional Google auth data
   */
  async login(email: string, password?: string, googleAuth?: {
    googleId: string;
    idToken: string;
    accessToken: string;
    name: string;
    photo?: string;
  }): Promise<LoginResponse> {
    const response = await this.request<LoginResponse>('/auth/login', {
      method: 'POST',
      requireAuth: false,
      body: {
        email,
        password,
        googleAuth,
      },
    });

    // Save auth token if login successful
    if (response.success && response.data?.token) {
      await this.setAuthToken(response.data.token);
    }

    return response;
  }

  /**
   * Register new user
   */
  async register(username: string, email: string, password?: string, googleAuth?: {
    googleId: string;
    idToken: string;
    accessToken: string;
    name: string;
    photo?: string;
  }): Promise<RegisterResponse> {
    const response = await this.request<RegisterResponse>('/auth/register', {
      method: 'POST',
      requireAuth: false,
      body: {
        username,
        email,
        password,
        googleAuth,
      },
    });

    // Save auth token if registration successful
    if (response.success && response.data?.token) {
      await this.setAuthToken(response.data.token);
    }

    return response;
  }

  /**
   * Verify auth token
   */
  async verifyToken(): Promise<{ success: boolean; user?: any }> {
    return this.request('/auth/verify', {
      method: 'GET',
      requireAuth: true,
    });
  }

  /**
   * Verify and fix wallet
   */
  async verifyWallet(): Promise<any> {
    return this.request('/auth/verify-wallet', {
      method: 'POST',
      requireAuth: true,
    });
  }

  /**
   * Request SUI from faucet
   */
  async requestFaucet(): Promise<FaucetResponse> {
    return this.request('/auth/faucet', {
      method: 'POST',
      requireAuth: true,
    });
  }

  // ==================== TREASURE ENDPOINTS ====================

  /**
   * Get nearby treasures
   */
  async getNearbyTreasures(latitude: number, longitude: number, radius: number = 5000): Promise<NearbyTreasuresResponse> {
    return this.request(`/treasures/nearby?lat=${latitude}&lng=${longitude}&radius=${radius}`, {
      method: 'GET',
      requireAuth: true,
    });
  }

  /**
   * Discover treasure
   */
  async discoverTreasure(
    treasureId: string,
    location: { latitude: number; longitude: number },
    locationProof: string,
    nfcData?: any,
    qrData?: any
  ): Promise<TreasureDiscoveryResponse> {
    return this.request('/treasures/discover', {
      method: 'POST',
      requireAuth: true,
      body: {
        treasureId,
        location,
        locationProof,
        nfcData,
        qrData,
      },
    });
  }

  /**
   * Verify treasure exists
   */
  async verifyTreasure(treasureId: string): Promise<any> {
    return this.request(`/treasures/verify/${treasureId}`, {
      method: 'GET',
      requireAuth: true,
    });
  }

  /**
   * Get all treasures (with pagination)
   */
  async getAllTreasures(page: number = 1, limit: number = 20, rarity?: number): Promise<any> {
    let query = `?page=${page}&limit=${limit}`;
    if (rarity) query += `&rarity=${rarity}`;
    
    return this.request(`/treasures${query}`, {
      method: 'GET',
      requireAuth: true,
    });
  }

  // ==================== PROFILE ENDPOINTS ====================

  /**
   * Get user profile stats
   */
  async getProfileStats(): Promise<ProfileStatsResponse> {
    return this.request('/profile/stats', {
      method: 'GET',
      requireAuth: true,
    });
  }

  /**
   * Update user profile
   */
  async updateProfile(username?: string, email?: string, avatarUrl?: string): Promise<any> {
    const body: any = {};
    if (username) body.username = username;
    if (email) body.email = email;
    if (avatarUrl) body.avatarUrl = avatarUrl;

    return this.request('/profile/update', {
      method: 'PUT',
      requireAuth: true,
      body,
    });
  }

  /**
   * Create blockchain profile
   */
  async createBlockchainProfile(username?: string): Promise<any> {
    return this.request('/profile/create-blockchain-profile', {
      method: 'POST',
      requireAuth: true,
      body: { username },
    });
  }

  /**
   * Get achievements
   */
  async getAchievements(category?: string, unlocked?: boolean): Promise<any> {
    let query = '';
    const params = [];
    if (category) params.push(`category=${category}`);
    if (unlocked !== undefined) params.push(`unlocked=${unlocked}`);
    if (params.length > 0) query = `?${params.join('&')}`;

    return this.request(`/profile/achievements${query}`, {
      method: 'GET',
      requireAuth: true,
    });
  }

  /**
   * Get leaderboard
   */
  async getLeaderboard(page: number = 1, limit: number = 50, sortBy: string = 'score'): Promise<any> {
    return this.request(`/profile/leaderboard?page=${page}&limit=${limit}&sortBy=${sortBy}`, {
      method: 'GET',
      requireAuth: true,
    });
  }

  /**
   * Get discovery history
   */
  async getDiscoveryHistory(page: number = 1, limit: number = 20, rarity?: number): Promise<any> {
    let query = `?page=${page}&limit=${limit}`;
    if (rarity) query += `&rarity=${rarity}`;

    return this.request(`/profile/discoveries${query}`, {
      method: 'GET',
      requireAuth: true,
    });
  }

  // ==================== WALLET ENDPOINTS ====================

  /**
   * Get wallet balance
   */
  async getWalletBalance(): Promise<WalletBalanceResponse> {
    return this.request('/wallet/balance', {
      method: 'GET',
      requireAuth: true,
    });
  }

  /**
   * Get wallet address
   */
  async getWalletAddress(): Promise<any> {
    return this.request('/wallet/address', {
      method: 'GET',
      requireAuth: true,
    });
  }

  /**
   * Get transaction history
   */
  async getTransactionHistory(page: number = 1, limit: number = 20, type?: string): Promise<any> {
    let query = `?page=${page}&limit=${limit}`;
    if (type) query += `&type=${type}`;

    return this.request(`/wallet/transactions${query}`, {
      method: 'GET',
      requireAuth: true,
    });
  }

  /**
   * Get NFT collection
   */
  async getNFTCollection(): Promise<NFTCollectionResponse> {
    return this.request('/wallet/nfts', {
      method: 'GET',
      requireAuth: true,
    });
  }

  /**
   * Request SUI from faucet (wallet endpoint)
   */
  async requestWalletFaucet(): Promise<FaucetResponse> {
    return this.request('/wallet/faucet', {
      method: 'POST',
      requireAuth: true,
    });
  }

  /**
   * Transfer SUI to another address
   */
  async transferSui(toAddress: string, amount: number, note?: string): Promise<any> {
    return this.request('/wallet/transfer', {
      method: 'POST',
      requireAuth: true,
      body: {
        toAddress,
        amount,
        note,
      },
    });
  }

  /**
   * Get wallet stats
   */
  async getWalletStats(): Promise<any> {
    return this.request('/wallet/stats', {
      method: 'GET',
      requireAuth: true,
    });
  }

  // ==================== UTILITY METHODS ====================

  /**
   * Health check
   */
  async healthCheck(): Promise<{ status: string; timestamp: string }> {
    return this.request('/wallet/health', {
      method: 'GET',
      requireAuth: false,
    });
  }

  /**
   * Get network info
   */
  getNetworkInfo() {
    return {
      baseUrl: this.baseUrl,
      hasAuthToken: !!this.authToken,
      network: 'testnet', // or get from config
    };
  }

  /**
   * Test connection to backend
   */
  async testConnection(): Promise<boolean> {
    try {
      await this.healthCheck();
      return true;
    } catch (error) {
      console.error('Backend connection test failed:', error);
      return false;
    }
  }
}

// Create singleton instance
export const apiService = new ApiService();

// Export for easy access in components
export default ApiService;